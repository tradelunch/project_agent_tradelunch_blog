# Category Insertion Implementation Plan

## Overview

Update `UploadingAgent` to insert categories into the database using hierarchical logic matching the TypeScript implementation.

---

## Current State Analysis

### TypeScript Implementation (Reference)
```typescript
// Input: categories: ['java', 'spring', 'jdbc']
// 1. Insert root: 'java' with id=group_id=rootId
// 2. Insert child 'spring' with parent_id=java_id, group_id=rootId, level=1
// 3. Insert child 'jdbc' with parent_id=spring_id, group_id=rootId, level=2
// Returns: last category ID (most specific)
```

### Python UploadingAgent (Current)
```python
# Current state:
# - NO category insertion logic
# - Only sets category_id in PostSchema validation
# - category_id is None or passed from elsewhere
```

---

## Schema Comparison

### Actual SQL Schema (`schema/posts.schema.sql`)
```sql
CREATE TABLE if not exists categories (
    seq int8 GENERATED ALWAYS AS IDENTITY,
    id int8 GENERATED BY DEFAULT AS IDENTITY,
    group_id int8 NULL,  -- Root category ID
    "level" int4 DEFAULT 0 NOT NULL,
    priority int4 DEFAULT 100 NOT NULL,
    parent_id int8 NULL,
    user_id int8 NOT NULL,
    title varchar(100) NOT NULL,  -- UNIQUE constraint
    created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
    updated_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
    deleted_at timestamp NULL,
    CONSTRAINT categories_pkey PRIMARY KEY (id),
    CONSTRAINT categories_seq_key UNIQUE (seq),
    CONSTRAINT categories_title_key UNIQUE (title)
);
```

### TypeScript Implementation (Reference)
```typescript
// TypeScript uses same field names as actual SQL:
id         BIGINT  (Generated by default as identity)
title      VARCHAR(100) UNIQUE  (ON CONFLICT title works!)
group_id   BIGINT  (Root category ID)
parent_id  BIGINT
level      INT
user_id    BIGINT  (Required, tracks who created it)
priority   INT  (Display order)
```

### Schema Alignment Status
| Field | Actual SQL | TypeScript | Python Schema | Status |
|-------|------------|------------|---------------|--------|
| Category name | `title` | `title` | `title` | ✅ Aligned |
| Root reference | `group_id` | `group_id` | `group_id` | ✅ Aligned |
| Unique constraint | `UNIQUE(title)` | `UNIQUE(title)` | N/A | ✅ Exists |
| User tracking | `user_id` (required) | `user_id` | `user_id` | ✅ Aligned |
| ID generation | Auto-identity | Auto-identity | Auto-identity | ✅ Aligned |
| Sequential ID | `seq` (always) | N/A | `seq` | ✅ Aligned |
| Priority | `priority` | `priority` | `priority` | ✅ Aligned |

**Decision:** All schemas are now aligned. Use `title`, `group_id`, `user_id`, `priority` as per actual SQL schema.

---

## Implementation Plan

### Phase 1: Schema Verification ✅ COMPLETE

#### Task 1.1: Review CategorySchema in `schema.py` ✅
- [x] Check if `title` field matches SQL ✅
- [x] Verify `group_id` (not `root_id`) ✅
- [x] Confirm auto-increment ID handling ✅
- [x] Add `user_id` field ✅
- [x] Add `seq`, `priority` fields ✅

**Current schema.py (VERIFIED CORRECT):**
```python
class CategorySchema(BaseModel):
    seq: Optional[int] = Field(default=None, description="Auto-generated sequential number (unique)")
    id: Optional[int] = Field(default=None, description="Category ID (auto-generated or manual)")
    group_id: Optional[int] = Field(default=None, description="Root category ID (self-reference for root)")
    level: int = Field(default=0, description="Hierarchy level (0 = root, 1+ = children)")
    priority: int = Field(default=100, description="Display order priority")
    parent_id: Optional[int] = Field(default=None, description="Parent category ID (NULL for root)")
    user_id: int = Field(description="User ID who created this category")
    title: str = Field(max_length=100, description="Category name (unique)")
    created_at: Optional[datetime] = Field(default=None, description="Creation timestamp")
    updated_at: Optional[datetime] = Field(default=None, description="Last update timestamp")
    deleted_at: Optional[datetime] = Field(default=None, description="Soft delete timestamp")
```

**Action:** ✅ Schema is complete and matches SQL exactly.

---

### Phase 2: Add Category Insertion Logic

#### Task 2.1: Create `_insert_categories` Method

**Location:** `agents/uploading_agent.py`

**Signature:**
```python
async def _insert_categories(
    self,
    categories: List[str],
    user_id: int,
    connection  # DB connection or MCP client
) -> Optional[int]:
    """
    Insert category hierarchy into database.

    Args:
        categories: Category hierarchy ['java', 'spring', 'jdbc']
        user_id: User ID for tracking
        connection: Database connection (psycopg2 or MCP)

    Returns:
        ID of the most specific (leaf) category
        None if no categories

    Example:
        categories = ['java', 'spring', 'jdbc']
        Returns: ID of 'jdbc' category
    """
```

#### Task 2.2: Implement Root Category Insertion

**Logic:**
```python
# 1. Split categories
root, *children = categories if categories else (None, [])

if not root:
    return None

# 2. Insert root category with user_id
# SQL with ON CONFLICT to handle duplicates
root_query = """
    INSERT INTO categories (title, parent_id, group_id, level, user_id, priority)
    VALUES (%s, NULL, NULL, 0, %s, 100)
    ON CONFLICT (title) DO UPDATE SET
        level = 0,
        parent_id = NULL,
        updated_at = CURRENT_TIMESTAMP
    RETURNING id
"""

# Note: group_id is set to NULL initially, then updated to self-reference
# We need to update it with its own ID after insertion
```

**Challenge:** `group_id` must equal the root's own `id`, but ID is auto-generated.

**Solution (Two-step approach):**
```python
# Step 1: Insert with group_id=NULL placeholder
cursor.execute(root_query, (root_title, user_id))
root_id = cursor.fetchone()[0]

# Step 2: Update group_id to self-reference
update_query = """
    UPDATE categories
    SET group_id = %s
    WHERE id = %s
"""
cursor.execute(update_query, (root_id, root_id))

return root_id
```

#### Task 2.3: Implement Child Categories Insertion

**Logic:**
```python
parent_id = root_id  # Start with root as parent
group_id = root_id   # All children share the same group_id (root)

for index, child_name in enumerate(children):
    level = index + 1  # Level 1 for first child, 2 for second, etc.

    # Insert child with parent linkage
    child_query = """
        INSERT INTO categories (title, parent_id, group_id, level, user_id, priority)
        VALUES (%s, %s, %s, %s, %s, 100)
        ON CONFLICT (title) DO UPDATE SET
            parent_id = EXCLUDED.parent_id,
            group_id = EXCLUDED.group_id,
            level = EXCLUDED.level,
            updated_at = CURRENT_TIMESTAMP
        RETURNING id
    """

    # Execute and get child_id
    cursor.execute(child_query, (child_name, parent_id, group_id, level, user_id))
    child_id = cursor.fetchone()[0]

    # Update parent_id for next iteration
    parent_id = child_id

return parent_id  # Return most specific category ID
```

#### Task 2.4: UNIQUE Constraint ✅ COMPLETE

**Status:** ✅ SQL schema already has `UNIQUE(title)` constraint.

**Constraint in SQL:**
```sql
CONSTRAINT categories_title_key UNIQUE (title)
```

**Result:** ON CONFLICT (title) works perfectly with existing constraint.

---

### Phase 3: Integrate with `_save_article`

#### Task 3.1: Update `_save_article` Method

**Current:**
```python
post_data = {
    # ...
    "category_id": data.get("category_id"),  # Not populated!
}
```

**Updated:**
```python
async def _save_article(self, data: Dict[str, Any]) -> Dict[str, Any]:
    # Extract categories from data
    categories = data.get("categories", [])
    user_id = data.get("user_id", 1)

    # Insert categories and get leaf category ID
    if categories and len(categories) > 0:
        category_id = await self._insert_categories(
            categories, user_id, self.db_connection
        )
        self._log(f"✓ Inserted category hierarchy: {' > '.join(categories)} (ID: {category_id})")
    else:
        category_id = None
        self._log("No categories to insert")

    # Use category_id in PostSchema
    post_data = {
        # ...
        "category_id": category_id,  # Now populated!
    }
```

---

### Phase 4: Database Connection Handling

#### Task 4.1: Add DB Connection to UploadingAgent

**Current:** Only has `self.mcp_client`

**Needed:** Add `self.db_connection` for direct database access

**Options:**
1. **Via MCP:** Keep using MCP client (add category insertion to MCP server)
2. **Direct DB:** Add psycopg2 connection to UploadingAgent
3. **Hybrid:** Direct DB for categories, MCP for files/posts

**Recommended:** Direct DB connection for simplicity.

**Implementation:**
```python
class UploadingAgent(BaseAgent):
    def __init__(self, s3_bucket: str = "my-blog-bucket", db_config: Dict = None):
        super().__init__(...)
        self.s3_bucket = s3_bucket
        self.mcp_client = None

        # Add database connection
        self.db_config = db_config or config.DB_CONFIG
        self.db_connection = None

    async def _get_db_connection(self):
        """Get or create database connection"""
        if not self.db_connection:
            import psycopg2
            self.db_connection = psycopg2.connect(**self.db_config)
        return self.db_connection
```

---

### Phase 5: Error Handling & Edge Cases

#### Task 5.1: Handle Edge Cases

**Edge Cases:**
1. Empty categories list → Return None, no insertion
2. Single category (root only) → Insert root, return its ID
3. Duplicate category names → ON CONFLICT update
4. Database errors → Rollback, return error
5. Long category hierarchy (10+ levels) → Log warning, proceed

#### Task 5.2: Add Transaction Support

```python
async def _insert_categories(self, categories, user_id, connection):
    """With transaction support"""
    cursor = connection.cursor()

    try:
        # Begin transaction (implicit in psycopg2)
        root_id = self._insert_root_category(cursor, root, user_id)

        for child in children:
            child_id = self._insert_child_category(cursor, child, parent_id, root_id, level, user_id)
            parent_id = child_id

        connection.commit()
        return parent_id

    except Exception as e:
        connection.rollback()
        self._log(f"Category insertion failed: {e}", "error")
        raise
```

---

## Task Breakdown (Step-by-Step)

### ✅ Step 1: Schema Verification
- [x] Verify `title` field in CategorySchema ✅
- [x] Verify `group_id` field in CategorySchema ✅
- [x] Verify `user_id` field exists ✅
- [x] Verify UNIQUE constraint on title exists ✅

### ⏳ Step 2: Create Helper Methods
- [ ] `_insert_root_category(cursor, title, user_id) -> int`
  - Insert with title, parent_id=NULL, group_id=NULL, level=0
  - Update group_id to self-reference
  - Return root category ID
- [ ] `_insert_child_category(cursor, title, parent_id, group_id, level, user_id) -> int`
  - Insert with title, parent_id, group_id, level, user_id
  - Handle ON CONFLICT (title)
  - Return child category ID

### ⏳ Step 3: Implement Main Method
- [ ] `_insert_categories(categories: List[str], user_id: int, connection) -> Optional[int]`
  - Split into root + children
  - Call _insert_root_category for first element
  - Loop through children calling _insert_child_category
  - Return leaf category ID

### ⏳ Step 4: Add DB Connection
- [ ] Add `db_config` parameter to `__init__`
- [ ] Add `_get_db_connection()` method
- [ ] Handle connection lifecycle (open/close)

### ⏳ Step 5: Integrate with _save_article
- [ ] Call `_insert_categories` before PostSchema validation
- [ ] Use returned `category_id` in post_data
- [ ] Add logging showing full category path

### ⏳ Step 6: Error Handling
- [ ] Wrap in try/except with rollback
- [ ] Handle edge cases (empty list, single category, duplicates)
- [ ] Add detailed error messages with context

### ⏳ Step 7: Testing
- [ ] Test with multi-level categories (['java', 'spring', 'jdbc'])
- [ ] Test with single category (['tutorials'])
- [ ] Test with empty categories ([])
- [ ] Test with duplicate category titles
- [ ] Test rollback on database errors
- [ ] Test category_id correctly set in posts table

---

## SQL Queries Reference

### Insert Root Category
```sql
-- Two-step approach (handles group_id self-reference)

-- Step 1: Insert root with group_id=NULL
INSERT INTO categories (title, parent_id, group_id, level, user_id, priority)
VALUES ('java', NULL, NULL, 0, 2, 100)
ON CONFLICT (title) DO UPDATE SET
    level = 0,
    parent_id = NULL,
    updated_at = CURRENT_TIMESTAMP
RETURNING id;  -- Returns root_id (e.g., 101)

-- Step 2: Update group_id to self-reference
UPDATE categories
SET group_id = 101
WHERE id = 101;
```

### Insert Child Category
```sql
-- Example: Insert 'spring' as child of 'java' (id=101)
INSERT INTO categories (title, parent_id, group_id, level, user_id, priority)
VALUES ('spring', 101, 101, 1, 2, 100)
ON CONFLICT (title) DO UPDATE SET
    parent_id = EXCLUDED.parent_id,
    group_id = EXCLUDED.group_id,
    level = EXCLUDED.level,
    updated_at = CURRENT_TIMESTAMP
RETURNING id;  -- Returns child_id (e.g., 102)
```

**Note:** ON CONFLICT (title) works because `title` has UNIQUE constraint.

---

## Migration Status ✅ NO MIGRATION NEEDED

### Schema Already Complete
The actual SQL schema already includes:
- ✅ `UNIQUE(title)` constraint
- ✅ `user_id` column (required)
- ✅ `priority` column
- ✅ `seq` auto-increment column
- ✅ All necessary indexes

**No database migration required!** The schema is ready for category insertion implementation.

---

## Example Flow

### Input
```python
data = {
    "title": "Spring JDBC Tutorial",
    "categories": ["java", "spring", "jdbc"],
    "user_id": 2,
    # ... other fields
}
```

### Process
```
1. _insert_categories(['java', 'spring', 'jdbc'], user_id=2)

   a. Insert root 'java':
      INSERT ... VALUES ('java', NULL, NULL, 0, 2, 100) RETURNING id  → 101
      UPDATE ... SET group_id = 101 WHERE id = 101

   b. Insert child 'spring':
      INSERT ... VALUES ('spring', 101, 101, 1, 2, 100) RETURNING id  → 102

   c. Insert child 'jdbc':
      INSERT ... VALUES ('jdbc', 102, 101, 2, 2, 100) RETURNING id  → 103

   Return: 103 (most specific category ID)

2. _save_article() uses category_id=103 in PostSchema
```

### Result in Database
```sql
-- categories table
| seq | id  | title  | parent_id | group_id | level | user_id | priority |
|-----|-----|--------|-----------|----------|-------|---------|----------|
| 1   | 101 | java   | NULL      | 101      | 0     | 2       | 100      | (root)
| 2   | 102 | spring | 101       | 101      | 1     | 2       | 100      |
| 3   | 103 | jdbc   | 102       | 101      | 2     | 2       | 100      | (leaf)

-- posts table
| id  | title                 | category_id | user_id |
|-----|-----------------------|-------------|---------|
| 456 | Spring JDBC Tutorial  | 103         | 2       | (most specific)

-- post_categories table (if using junction table for full path)
| post_id | category_id |
|---------|-------------|
| 456     | 101         | (java)
| 456     | 102         | (spring)
| 456     | 103         | (jdbc)
```

---

## Testing Strategy

### Unit Tests
```python
# test_category_insertion.py

async def test_insert_single_category():
    """Test inserting root category only"""
    agent = UploadingAgent(db_config=TEST_DB_CONFIG)
    categories = ["tutorials"]
    category_id = await agent._insert_categories(categories, user_id=1, conn)
    assert category_id is not None
    # Verify in DB: level=0, parent_id=0, root_id=category_id

async def test_insert_hierarchy():
    """Test inserting multi-level hierarchy"""
    agent = UploadingAgent(db_config=TEST_DB_CONFIG)
    categories = ["java", "spring", "jdbc"]
    category_id = await agent._insert_categories(categories, user_id=1, conn)
    # Verify: returns leaf category ID
    # Verify: all 3 categories exist with correct parent/root relationships

async def test_duplicate_categories():
    """Test ON CONFLICT behavior"""
    agent = UploadingAgent(db_config=TEST_DB_CONFIG)
    # Insert once
    id1 = await agent._insert_categories(["java", "spring"], user_id=1, conn)
    # Insert again (should update, not duplicate)
    id2 = await agent._insert_categories(["java", "spring"], user_id=1, conn)
    # Verify: only one 'java' and one 'spring' in DB

async def test_empty_categories():
    """Test with empty categories list"""
    agent = UploadingAgent(db_config=TEST_DB_CONFIG)
    result = await agent._insert_categories([], user_id=1, conn)
    assert result is None
```

### Integration Tests
```python
# test_full_upload_with_categories.py

async def test_full_article_upload_with_categories():
    """Test complete flow: extract → upload with category insertion"""
    scanner = DocumentScannerAgent()
    scan_result = await scanner.run(...)

    extractor = ExtractingAgent()
    extract_result = await extractor.run(...)
    # extract_result["data"]["categories"] = ["java", "spring", "jdbc"]

    uploader = UploadingAgent(db_config=TEST_DB_CONFIG)
    upload_result = await uploader.run(...)

    # Verify:
    # 1. Categories inserted in DB
    # 2. post.category_id points to leaf category
    # 3. Published URL includes category path
```

---

## Estimated Effort

| Task | Estimated Time | Priority |
|------|----------------|----------|
| 1. Schema review/update | 30 min | High |
| 2. Add UNIQUE migration | 15 min | High |
| 3. Implement `_insert_categories` | 2 hours | High |
| 4. Add DB connection handling | 1 hour | High |
| 5. Integrate with `_save_article` | 30 min | High |
| 6. Error handling & edge cases | 1 hour | Medium |
| 7. Unit tests | 2 hours | Medium |
| 8. Integration tests | 1 hour | Low |
| 9. Documentation | 30 min | Low |

**Total:** ~8-9 hours

---

## Questions Resolved ✅

1. **user_id in categories:** ✅ RESOLVED
   - Actual SQL schema has `user_id BIGINT NOT NULL`
   - **Implementation:** Required field, must be passed to all category insertions

2. **ID generation:** ✅ RESOLVED
   - Actual SQL schema uses `GENERATED BY DEFAULT AS IDENTITY`
   - **Implementation:** Use auto-increment, database handles ID generation

3. **UNIQUE constraint on title:** ✅ RESOLVED
   - Actual SQL schema has `CONSTRAINT categories_title_key UNIQUE (title)`
   - **Implementation:** ON CONFLICT (title) works perfectly

4. **seq vs id:** ✅ RESOLVED
   - `seq`: GENERATED ALWAYS (never manually set)
   - `id`: GENERATED BY DEFAULT (can be manually set if needed)
   - **Implementation:** Let database handle both, use id for references

5. **post_categories junction table:** ⏳ TO BE DECIDED
   - Should we insert into post_categories for ALL categories in hierarchy?
   - Or just use posts.category_id for leaf category?
   - **Current approach:** Start with posts.category_id only (simpler)
   - **Future enhancement:** Add post_categories population if needed for multi-category queries

---

## Next Steps

1. ✅ **Review this plan** - Get feedback on approach
2. ✅ **Create SQL migration** - Add UNIQUE constraint
3. ✅ **Implement category insertion** - Step-by-step tasks
4. ✅ **Add tests** - Verify correctness
5. ✅ **Update documentation** - Document new behavior

---

## References

- TypeScript implementation (provided code)
- `schema/posts.schema.sql` - Database schema
- `schema.py` - Pydantic models
- `agents/uploading_agent.py` - Current implementation
- `CATEGORY_EXTRACTION.md` - How categories are extracted
